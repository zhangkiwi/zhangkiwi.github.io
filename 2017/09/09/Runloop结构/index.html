<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Runloop结构 | Kiwi</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Runloop结构</h1><a id="logo" href="/.">Kiwi</a><p class="description">志存高远，脚踏实地</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Runloop结构</h1><div class="post-meta">Sep 9, 2017</div><div class="post-content"><p>本文剖析Runloop各个类的数据结构，Runloop的作用等。</p>
<h2 id="RunLoop基本作用"><a href="#RunLoop基本作用" class="headerlink" title="RunLoop基本作用"></a>RunLoop基本作用</h2><ol>
<li>保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行。</li>
<li>处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）。</li>
<li>节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情。</li>
</ol>
<h2 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fundation框架 （基于CFRunLoopRef的封装）</span><br><span class="line">NSRunLoop对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CoreFoundation</span><br><span class="line">CFRunLoopRef对象</span><br></pre></td></tr></table></figure>
<p>Fundation框架是基于CFRunLoopRef的一层OC封装，这里主要研究CFRunLoopRef<a href="https://github.com/opensource-apple/CF/blob/master/CFRunLoop.c#L2021" target="_blank" rel="noopener">源码</a>。</p>
<h2 id="RunLoop相关类"><a href="#RunLoop相关类" class="headerlink" title="RunLoop相关类"></a>RunLoop相关类</h2><p>CoreFoundation 与Runloop有关的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line"></span><br><span class="line">CFRunLoopModeRef</span><br><span class="line"></span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line"></span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line"></span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>
<p>五个类的关系：</p>
<ol>
<li>一个线程对应一个Runloop。</li>
<li>一个CFRunLoop对应多个CFRunLoopMode</li>
<li>一个CFRunLoopMode对应多个Source/Timer/Observer</li>
</ol>
<h3 id="CFRunLoopRef-数据结构"><a href="#CFRunLoopRef-数据结构" class="headerlink" title="CFRunLoopRef 数据结构"></a>CFRunLoopRef 数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;          /* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面源码看出一个Runloop对应一条线程，一个runloop里面可以有多个CFRunLoopModeRef(模式）。</p>
<p>同一个时刻，RunLoop只能是在一个mode上面的运行。如果需要切换mode,只能是退出currentMode ,切换到指定的 mode 。</p>
<h3 id="CFRunLoopModeRef数据结构"><a href="#CFRunLoopModeRef数据结构" class="headerlink" title="CFRunLoopModeRef数据结构"></a>CFRunLoopModeRef数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RunLoop有五种模式，一般就用第一种和第二种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line">UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br><span class="line">UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</span><br><span class="line">GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</span><br><span class="line">kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</span><br></pre></td></tr></table></figure>
<p>从上面源码看出一个RunloopMode对应多个sources，和多个observers/timers。一个 RunLoop 在某个 mode 下运行时，不会接收和处理其他 mode 的事件 。如果要同步不同Mode中的observers/timers/sources到多个Mode中可用kCFRunLoopCommonModes，kCFRunLoopCommonModes，它不是一个真正的 mode，而是若干个 mode 的集合。<br>要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer。</p>
<h3 id="SourceRef-TimerRef-ObserverRef-数据结构"><a href="#SourceRef-TimerRef-ObserverRef-数据结构" class="headerlink" title="SourceRef/TimerRef/ObserverRef 数据结构"></a>SourceRef/TimerRef/ObserverRef 数据结构</h3><p>Source分为两种</p>
<ol>
<li>Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕）</li>
<li>Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）</li>
</ol>
<p>很多时候我们的 app 都是处于什么事都不干的状态，在空闲前指定用于唤醒的 mach port 端口，然后在空闲时被 mach_msg() 函数阻塞着并监听唤醒端口， mach_msg() 又会调用 mach_msg_trap() 函数从用户态切换到内核态，这样系统内核就将这个线程挂起，一直停留在 mac_msg_trap 状态。直到另一个线程向内核发送这个端口的 msg 后， trap 状态被唤醒， RunLoop 继续开始干活。</p>
<p>Timer</p>
<p>基于Time的事件源</p>
<p>Observer</p>
<p>主要用途就是监听 RunLoop 的状态变化，它可以监听RunLoop的7种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 即将进入 loop</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">// 即将处理 timer</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">// 即将处理 source</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">// 即将 sleep</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">// 刚被唤醒，退出 sleep</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">// 即将退出</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br></pre></td></tr></table></figure>
<h2 id="RunLoop-运行逻辑"><a href="#RunLoop-运行逻辑" class="headerlink" title="RunLoop 运行逻辑"></a>RunLoop 运行逻辑</h2><p>先来看源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"> </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再贴一幅网上的运行逻辑流程图：<br><img src="https://github.com/zhangkiwi/images/raw/master/runloop-01.png" alt="图一"></p>
<h2 id="RunLoop和线程间的关系"><a href="#RunLoop和线程间的关系" class="headerlink" title="RunLoop和线程间的关系"></a>RunLoop和线程间的关系</h2><ol>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value</li>
<li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li>
<li>RunLoop在第一次获取时创建，在线程结束时销毁</li>
</ol>
<p>下面查看源码。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CFRunLoopRef</span> <span class="string">CFRunLoopGetCurrent(void)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">CHECK_FOR_FORK();</span></span><br><span class="line">    <span class="string">CFRunLoopRef</span> <span class="string">rl</span> <span class="string">=</span> <span class="string">(CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(rl)</span> <span class="string">return</span> <span class="string">rl;</span></span><br><span class="line">    <span class="string">return</span> <span class="string">_CFRunLoopGet0(pthread_self());</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">_CFRunLoopGet0方法内部</span></span><br><span class="line"><span class="string">CF_EXPORT</span> <span class="string">CFRunLoopRef</span> <span class="string">_CFRunLoopGet0(pthread_t</span> <span class="string">t)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(pthread_equal(t,</span> <span class="string">kNilPthreadT))</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">t</span> <span class="string">=</span> <span class="string">pthread_main_thread_np();</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">__CFLock(&amp;loopsLock);</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(!__CFRunLoops)</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">__CFUnlock(&amp;loopsLock);</span></span><br><span class="line">    <span class="string">CFMutableDictionaryRef</span> <span class="string">dict</span> <span class="string">=</span> <span class="string">CFDictionaryCreateMutable(kCFAllocatorSystemDefault,</span> <span class="number">0</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">&amp;kCFTypeDictionaryValueCallBacks);</span></span><br><span class="line">    <span class="string">//</span> <span class="string">根据传入的主线程获取主线程对应的RunLoop</span></span><br><span class="line">    <span class="string">CFRunLoopRef</span> <span class="string">mainLoop</span> <span class="string">=</span> <span class="string">__CFRunLoopCreate(pthread_main_thread_np());</span></span><br><span class="line">    <span class="string">//</span> <span class="string">保存主线程</span> <span class="string">将主线程-key和RunLoop-Value保存到字典中</span></span><br><span class="line">    <span class="string">CFDictionarySetValue(dict,</span> <span class="string">pthreadPointer(pthread_main_thread_np()),</span> <span class="string">mainLoop);</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(!OSAtomicCompareAndSwapPtrBarrier(NULL,</span> <span class="string">dict,</span> <span class="string">(void</span> <span class="string">*</span> <span class="string">volatile</span> <span class="string">*)&amp;__CFRunLoops))</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">CFRelease(dict);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">CFRelease(mainLoop);</span></span><br><span class="line">        <span class="string">__CFLock(&amp;loopsLock);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">//</span> <span class="string">从字典里面拿，将线程作为key从字典里获取一个loop</span></span><br><span class="line">    <span class="string">CFRunLoopRef</span> <span class="string">loop</span> <span class="string">=</span> <span class="string">(CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops,</span> <span class="string">pthreadPointer(t));</span></span><br><span class="line">    <span class="string">__CFUnlock(&amp;loopsLock);</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">//</span> <span class="string">如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(!loop)</span> <span class="string">&#123;</span>  </span><br><span class="line">    <span class="string">CFRunLoopRef</span> <span class="string">newLoop</span> <span class="string">=</span> <span class="string">__CFRunLoopCreate(t);</span></span><br><span class="line">        <span class="string">__CFLock(&amp;loopsLock);</span></span><br><span class="line">    <span class="string">loop</span> <span class="string">=</span> <span class="string">(CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops,</span> <span class="string">pthreadPointer(t));</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">//</span> <span class="string">创建好之后，以线程为key</span> <span class="string">runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(!loop)</span> <span class="string">&#123;</span> </span><br><span class="line">        <span class="string">CFDictionarySetValue(__CFRunLoops,</span> <span class="string">pthreadPointer(t),</span> <span class="string">newLoop);</span></span><br><span class="line">        <span class="string">loop</span> <span class="string">=</span> <span class="string">newLoop;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">        <span class="string">//</span> <span class="string">don't</span> <span class="string">release</span> <span class="string">run</span> <span class="string">loops</span> <span class="string">inside</span> <span class="string">the</span> <span class="string">loopsLock,</span> <span class="string">because</span> <span class="string">CFRunLoopDeallocate</span> <span class="string">may</span> <span class="string">end</span> <span class="string">up</span> <span class="string">taking</span> <span class="string">it</span></span><br><span class="line">        <span class="string">__CFUnlock(&amp;loopsLock);</span></span><br><span class="line">    <span class="string">CFRelease(newLoop);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(pthread_equal(t,</span> <span class="string">pthread_self()))</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">_CFSetTSD(__CFTSDKeyRunLoop,</span> <span class="string">(void</span> <span class="string">*)loop,</span> <span class="literal">NULL</span><span class="string">);</span></span><br><span class="line">        <span class="string">if</span> <span class="string">(0</span> <span class="string">==</span> <span class="string">_CFGetTSD(__CFTSDKeyRunLoopCntr))</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">_CFSetTSD(__CFTSDKeyRunLoopCntr,</span> <span class="string">(void</span> <span class="string">*)(PTHREAD_DESTRUCTOR_ITERATIONS-1),</span> <span class="string">(void</span> <span class="string">(*)(void</span> <span class="string">*))__CFFinalizeRunLoop);</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">return</span> <span class="string">loop;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可[NSRunLoop currentRunLoop];如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop<br>[NSRunLoop currentRunLoop];方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。</p>
<h2 id="Runloop-应用"><a href="#Runloop-应用" class="headerlink" title="Runloop 应用"></a>Runloop 应用</h2><h3 id="实现常驻线程"><a href="#实现常驻线程" class="headerlink" title="实现常驻线程"></a>实现常驻线程</h3><ol>
<li>为当前线程开启一个Runloop,</li>
<li>向该Runloop中添加一个Port/Source等维持Runloop的事件循环,</li>
<li>启动该Runloop。</li>
</ol>
<h3 id="AFNetWorking-里面的常驻线程"><a href="#AFNetWorking-里面的常驻线程" class="headerlink" title="AFNetWorking 里面的常驻线程"></a>AFNetWorking 里面的常驻线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">        static NSThread *_networkRequestThread = nil;</span><br><span class="line">        static dispatch_once_t oncePredicate;</span><br><span class="line">        dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">            // 创建一个线程，并在该线程上执行下一个方法</span><br><span class="line">            _networkRequestThread = [[NSThread alloc] initWithTarget:self</span><br><span class="line">                                                            selector:@selector(networkRequestThreadEntryPoint:)</span><br><span class="line">                                                              object:nil];</span><br><span class="line">            // 开启线程</span><br><span class="line">            [_networkRequestThread start];</span><br><span class="line">        &#125;);</span><br><span class="line">        return _networkRequestThread;</span><br><span class="line">    &#125;</span><br><span class="line">/* 在新开的线程中执行的第一个方法 */</span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        // 获取当前线程对应的 RunLoop</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        // 为 RunLoop 添加 source，模式为 DefaultMode</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        // 开始运行 RunLoop</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>APP 启动之后，苹果在主线程对应的 RunLoop 里面注册了两个 Observer, 其回调都是</p>
<p>_wrapRunLoopWithAutoreleasePoolHandler（）。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<p>与主线程的 RunLoop 运行逻辑类似，在程序中自定义的自动释放池，也是在即将退出 RunLoop 的时候，释放创建的自动释放池。</p>
</div><div class="tags"><a href="/tags/Objective-C/">Objective-C</a></div><div class="post-nav"><a class="next" href="/2016/09/09/load和initialize/">+load和+initialize</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://zhangkiwi.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Objective-C/">Objective-C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/block/" style="font-size: 15px;">block</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/09/Runloop结构/">Runloop结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/load和initialize/">+load和+initialize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/GCD实现多读单写/">GCD实现多读单写</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/KVO 原理/">KVO 原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/Runtime之关联对象/">Runtime之关联对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/Runtime基础/">Runtime基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/07/深拷贝与浅拷贝/">深拷贝与浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/26/Block探究/">Block探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/24/多线程之GCD(二)/">多线程之GCD(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/19/多线程之GCD(一)/">多线程之GCD（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://southpeak.github.io/" title="南峰子的技术博客" target="_blank">南峰子的技术博客</a><ul></ul><a href="http://www.leichunfeng.com/blog/archives/" title="雷纯锋的技术博客" target="_blank">雷纯锋的技术博客</a><ul></ul><a href="http://www.iosxxx.com/archives/" title="向晨宇的技术博客" target="_blank">向晨宇的技术博客</a><ul></ul><a href="http://allluckly.cn/tags/index.html#%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%8C%E7%A0%81%E5%86%9C%E4%BA%BA%E7%94%9F%EF%BC%8CiOS%E5%BC%80%E5%8F%91" title="iOS开发" target="_blank">iOS开发</a><ul></ul><a href="https://draveness.me/index" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="http://www.beyondabel.com/blog/archives/" title="Abel's Den" target="_blank">Abel's Den</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Kiwi.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>